<!-- 

  gpolygons.xml    FinInG package documentation
                                                                   John Bamberg
                                                                   Anton Betten
                                                                   Jan De Beule
                                                                  Philippe Cara
                                                                 Michel Lavrauw
                                                            and Max Neunhoeffer

Copyright (C) 2014,         Colorado State University
                            UniversitÃ  degli Studi di Padova
                            Universiteit Gent
                            University of St. Andrews
                            University of Western Australia     
                            Vrije Universiteit Brussel

This is the chapter of the documentation describing generalised polygons.
-->


<!--
Documentaion check-list:
- Projective planes
  - ProjectivePlaneByBlocks (done)
  - ProjectivePlaneByIncidenceMatrix (done)
- Generalised Quadrangles
  - Kantor families (done)
  - q Clans and BLT sets (done)
- Generalised Hexagons (done)
- General operations
  - Order (done)
  - AmbientSpace (done)
  - CollineationGroup (done)
  - CollineationAction (done)
  - BlockDesignOfGeneralisedPolygon
  - IncidenceGraphOfGeneralisedPolygon
  - IncidenceMatrixOfGeneralisedPolygon

-->


<Chapter Label="gpolygons">
<Heading>Generalised Polygons</Heading>

A <E>generalised n-gon</E> is a point/line geometry whose incidence graph is bipartite
of diameter <A>n</A> and girth <A>2n</A>. Although these rank 2 structures are very
much a subdomain of <Package>Grape</Package> and <Package>Design</Package>, their significance in
finite geometry warrants their inclusion in <Package>FinInG</Package>. By the famous
theorem of Feit and Higman, a generalised n-gon which has at least three points on every line,
must have <M>n</M> in <M>\{2,3,4,6,8 \}</M>. The case <M>n=2</M> concerns the complete multipartite graphs,
which we disregard. The more interesting cases are accordingly projective planes (<M>n=3</M>),
generalised quadrangles (<M>n=4</M>), generalised hexagons (<M>n=6</M>) and generalised octagons (<M>n=8</M>).
<P/>
<Package>FinInG</Package> provides some basic functionality to deal with generalised polygons as
incidence geometries. A lot of non-trivial interaction with the package <Package>grape</Package> has been
very useful and even necessary. Currently, generic functions to create generalised polygons, to create
elements of generalised polygons, and to explore the elements are implemented. This generic functionaliy
allows the user to construct generalised polygons through many different objects available in
GAP and <Package>FinInG</Package>. Apart from these generic functions, some particular generalised polygons are
available: the classical generalised hexagons and elation generalised quadrangles from different perspectives
can be constructed.<P/>


<Section>
<Heading>Categories</Heading>

<ManSection>
<Filt Name="IsGeneralisedPolygon" Type="Category"/>
<Filt Name="IsGeneralisedPolygonRep" Type="Representation"/>
<Description>
This category is a subcategory of <C>IsIncidenceGeometry</C>, and contains all generalised polygons.
Generalised polygons constructed through functions described in this chapter, all belong
to <C>IsGeneralisedPolygonRep</C>.
</Description>
</ManSection>

<ManSection>
<Heading>Subcategories in <C>IsGeneralisedPolygon</C></Heading>
<Filt Name="IsProjectivePlane" Type="Category"/>
<Filt Name="IsGeneralisedQuadrangle" Type="Category"/>
<Filt Name="IsGeneralisedHexagon" Type="Category"/>
<Filt Name="IsGeneralisedOctagon" Type="Category"/>
<Description>
All generalised polygons in <Package>FinInG</Package> belong to one of these four categories. It is not
possible to construct generalised polygons of which the gonality is not known (or checked). Note that the
classical generalised quadrangles (which are the classical polar spaces of rank 2) belong
also to <C>IsGeneralisedQuadrangle</C> and that the desarguesian projective planes (which are the projective
spaces of dimension 2) also belong to <C>IsProjectivePlane</C>, but both do not belong
to <C>IsGeneralisedPolygonRep</C>.
</Description>
</ManSection>

<ManSection>
<Heading>Subcategories in <C>IsProjectivePlane</C></Heading>
<Filt Name="IsDesarguesianPlane" Type="Category"/>
<Description>
<C>IsDesarguesianPlane</C> is declared as a subcategory of <C>IsProjectivePlane</C> and 
<C>IsProjecticeSpace</C>. Projective spaces of dimension 2 constructed using <F>ProjectiveSpace</F>
belong to <C>IsDesarguesianPlane</C>.
</Description>
</ManSection>

<ManSection>
<Heading>Subcategories in <C>IsGeneralisedQuadrangle</C></Heading>
<Filt Name="IsClassicalGQ" Type="Category"/>
<Filt Name="IsElationGQ" Type="Category"/>
<Description>
<C>IsClassicalGQ</C> is declared as a subcategory of <C>IsGeneralisedQuadrangle</C> and 
<C>IsClassicalPolarSpace</C>. All classical polar spaces of rank 2 belong to <C>IsClassicalGQ</C>.
<C>IsElationGQ</C> is declared as subcategory of <C>IsGeneralisedQuadrangle</C>. Elation GQs will be 
discusedd in detail in Section <Ref Sect="EGQ"/>
<Example>
<#Include SYSTEM "../examples/include/gpolygons_categories1.include">
</Example>
</Description>
</ManSection>

<ManSection>
<Filt Name="IsClassicalGeneralisedHexagon" Type="Category"/>
<Description>
<C>IsClassicalGeneralisedHexagon</C> is declared as subcategory of <C>IsGeneralisedHexagon</C> and <C>IsLieGeometry</C>.
The so called classical generalised hexagons are the hexagons that come from the triality of the hyperbolic quadric 
<Alt Only="LaTeX"><M>Q^+(7,q)</M></Alt><Alt Only="HTML">Q&lt;sup>+&lt;/sup>(7,q)</Alt>.
The Split Cayley hexagon is embedded in the parabolic quadric <M>Q(6,q)</M>. The twisted triality hexagon
is embedded in the hyperbolic quadric <Alt Only="LaTeX"><M>Q^+(7,q)</M></Alt>
<Alt Only="HTML">Q&lt;sup>+&lt;/sup>(7,q)</Alt>. The constuction of these hexagons in a subcategoy 
of <C>IsLieGeometry</C>makes typical operations for Lie geometries applicable. The classical 
generalised hexagons are in detail discussed in Section <Ref Sect="CGH"/>
<Example>
<#Include SYSTEM "../examples/include/gpolygons_categories2.include">
</Example>
</Description>
</ManSection>

</Section>

<Section>
<Heading>Generic functions to create generalised polygons</Heading>

<ManSection>
<Oper Name="GeneralisedPolygonByBlocks" Arg="l"/>
<Returns>a generalised polygon</Returns>
<Description>
The argument <A>l</A> is a finite homogeneous list consisting of
ordered sets of a common size <M>n+1</M>. This operation will assume that
each element of <A>l</A> represents a line of the generalised polygon. Its
points are assumed to be the union of all elements of <A>l</A>. The incidence
is assumed to be symmetrised containment. From this information, an incidence
grap is coputed using <Package>grape</Package>. If this graph has diameter <M>d</M>
and girth <M>2d</M>, with <M>d \in \{3,4,6,8\}</M>, a generalised polygon is returned.
Note that for large input, this operation can be time consuming.
<Example>
<#Include SYSTEM "../examples/include/gpolygons_gpbyblocks.include">
</Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="GeneralisedPolygonByIncidenceMatrix" Arg="incmat"/>
<Returns>a generalised polygon</Returns>
<Description>
The argument <M>incmat</M> is a matrix representing the incidence matrix of a point line geometry.
The points are represented by the columns, the rows represent the lines. From <A>incmat</A> a homogeneous
list of sets of column entries is derived, which is then passed to <F>GeneralisedPolygonByBlocks</F>. When
<A>incmat</A> indeed represets a generalised poygon, it is returned. The checks are performed
by <F>GeneralisedPolygonByBlocks</F>.
<Example>
<#Include SYSTEM "../examples/include/gpolygons_gpbyincmat.include">
</Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="GeneralisedPolygonByElements" Arg="pts, lns, inc"/>
<Oper Name="GeneralisedPolygonByElements" Arg="pts, lns, inc, grp, act"/>
<Returns>a generalised polygon</Returns>
<Description>
The argument <A>pts</A>, <A>lns</A> and <A>inc</A> are respectively a set of objects, a set of objects
and a function. The function <A>inc</A> must represent an incidence relation between objects of <A>pts</A>
and <A>lns</A>. The first version of <F>GeneralisedPolygonByElements</F> will construct an incidence graph, and
if this graph has diameter <M>d</M> and girth <M>2d</M>, with <M>d \in \{3,4,6,8\}</M>,
a generalised polygon is returned. The argument <A>grp</A> is a group, and <A>act</A> a function, representing
an action of the elements of <A>grp</A> on the objects in the lists <A>pts</A> and <A>lns</A>, preserving
the incidence. The second version of <F>GeneralisedPolygonByElements</F> will construct an incidence graph, and
if this graph has diameter <M>d</M> and girth <M>2d</M>, with <M>d \in \{3,4,6,8\}</M>,
a generalised polygon is returned. If <A>grp</A> is a non trivial group, the construction of the graph will
be faster. This operation can be typically used to construct generalised polygons from objects that are available
in <Package>Fining</Package>. This difference in time is shown in the first two examples. The third examples
shows the construction of the generalised quadrangle <M>T_2(O)</M>.
<Example>
<#Include SYSTEM "../examples/include/gpolygons_gpbyelements.include">
</Example>
</Description>
</ManSection>

</Section>

<Section Label="gp:operations">
<Heading>Attributes and operations for generalised polygons</Heading>

All operations described in this section are applicable on objects in the category <C>IsGeneralisedPolygon</C>.

<ManSection>
<Attr Name="Order" Arg="gp"/>
<Returns>a pair of positive integers</Returns>
<Description>
This method returns the parameters <M>(s,t)</M> of the generalised polygon <A>gp</A>. That is,
<M>s+1</M> is the number of points on any line of <A>gp</A>, and <M>t+1</M> is the number
of lines incident with any point of <A>gp</A>.
<Example>
<#Include SYSTEM "../examples/include/gpolygons_order.include">
</Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="IncidenceGraphOfGeneralisedPolygonAttr" Arg="gp"/>
<Description>
This attribute is declared for objects in <C>IsGeneralisedPolygon</C>. It is a mutable
attribute and can be accesed by the operation <F>IncidenceGraphOfGeneralisedPolygon</F>.
</Description>
</ManSection>

<ManSection>
<Oper Name="IncidenceGraphOfGeneralisedPolygon" Arg="gp"/>
<Returns>a graph</Returns>
<Description>
The argument <A>gp</A> is a generalised polygon. This operation returns the incidence graph of
<A>gp</A>. If <A>gp</A> is constructed using <F>GeneralisedPolygonByBlocks</F>, <F>GeneralisedPolygonByElements</F>
or <F>GeneralisedPolygonByIncidenceMatrix</F>, an incidence graph is computed to check the input, and is stored 
as an attribute. For the particular generalised polygons available in <Package>Fining</Package>, there is
no precomputed incidence graph. Note that computing an incidence graph may require some time, especially when
the <A>gp</A> has no collineation group computed. Therefore, this operation will return an error when <A>gp</A>
has no collineation group computed. As <F>CollineationGroup</F> is an attribute for objects in 
<C>IsGeneralisedPolygon</C>, the user should computed the collineation group and then reissue the command to compute
the incidence graph.<P/>
We should also point out that this method returns a <E>mutable</E> attribute
of <A>gp</A>, so that accquired information about the incidence graph can be added. For example,
the automorphism group of the incidence graph may be computed and stored as a record component 
after the incidence graph is stored as an attribute of <A>gp</A>. Normally, attributes of GAP objects are immutable.<P/>
Note that the factor 2 as difference in the order of the collineation group of <M>Q(4,4)</M> and the order of the
automorphism group of its incidence graph is easily explained by the fact that the <M>Q(4,4)</M> is self dual.
<Example>
<#Include SYSTEM "../examples/include/gpolygons_incgraph.include"> 
</Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="IncidenceMatrixOfGeneralisedPolygon" Arg="gp"/>
<Returns>a matrix</Returns>
<Description>
This method returns the incidence matrix of the generalised polygon via
the operation <C>CollapsedAdjacencyMat</C> in the <Package>GRAPE</Package>
package (so you need to load this package first). The rows of the matrix
correspond to the points of <A>gp</A>, and the columns correspond to the lines.
Note that since this operation relies on <F>IncidenceGraphOfGeneralisedPolygon</F>,
for some generalised polygons, it is necessary to compute a collineation group first.
<Example>
<#Include SYSTEM "../examples/include/gpolygons_incmatrix.include"> 
</Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="CollineationGroup" Arg="gp"/>
<Returns>a group</Returns>
<Description>
This attribute returns the full collineation group of the generalised polygon <A>gp</A>. 
For some particular generalised polygons, a (subgroup) of the full collineation group
can be computed efficiently without computing the incidence graph of <A>gp</A>: the full 
collienation group of classical generalised quadrangles and classical generalised hexagons;
and an elation group with relation to a basepoint of an elation generalised quadrangle. For 
generalised polygons constructed by the operations <F>GeneralisedPolygonByBlocks</F>, 
<F>GeneralisedPolygonByElements</F> or <F>GeneralisedPolygonByIncidenceMatrix</F>, the 
full collineation group is computed using the full automorphism group of the underlying
incidence graph, the latter being computed by the package <Package>GRAPE</Package>.<P/>
The collineation groups computed for classical generalised quadrangles and classical 
generalised hexagons are collineation groups in the sense of <Package>FinInG</Package>, and
come equipped with a NiceMonomorphism. The collineation groups computed in all other cases 
are permutations groups, acting on the vertices of the underlying incidence graph.<P/>
Note that the computation of the automorphism group of the underlying graph can be time
consuming, also if the complete collineation group of the generalised polygon has been
used as an argument in e.g. <F>GeneralisedPolygonByElements</F>.<P/>
The first example illustrates that <F>CollineationGroup</F> is of course applicable to
all classical generalised Polygons.
<Example>
<#Include SYSTEM "../examples/include/gpolygons_collineationgroup1.include">
</Example>
The second example illustrates the computation of collineation groups generalised polygons constructed
using different objects. The thrid generalised polygon is known as <M>T_2(O)^</M>.
<Example>
<#Include SYSTEM "../examples/include/gpolygons_collineationgroup2.include">
</Example>
In the third example, the use of an precomputed automorphism group is illustrated. It speeds up
the construction of the underlying graph and the computation of the automorphism group of the
underlying graph. However, as is also illustrated in the example, despite that the precomputed
automorhism group of the generalised polygon is actually the full collineation group, still some
time is needed to compute the automorhism group of the underlying graph. The timings after both
<F>CollineationGroup</F> commands are wrong. This is because <Package>GRAPE</Package> relies on
an external binary to computed the automorhism group of a graph.
<Example>
<#Include SYSTEM "../examples/include/gpolygons_collineationgroup3.include">
</Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="CollineationAction" Arg="group"/>
<Returns>a function</Returns>
<Description>
<A>group</A> is a collineation group of a generalised polygon, computed using
<F>CollineationGroup</F>. The collineation group of classical generalised polygons
will be a collineation group in the sense of <Package>FinInG</Package>. The natural action
is <F>OnProjectiveSubspaces</F>. The collineation group of any other generalised polygons
will be a permutation group. The result of <F>CollineationAction</F> for such a group
is a function with input a pair <A>(x,g)</A> where <A>x</A> is an element of
the generalised polygon, and <A>g</A> is a collineation of the generalised polygon,
so an element of <A>group</A>. The example illustrates the use in the generalised quadrangle.
<Example>
<#Include SYSTEM "../examples/include/gpolygons_collineations.include">
</Example>
</Description>
</ManSection>

<ManSection>
<Attr Name="BlockDesignOfGeneralisedPolygon" Arg="gp"/>
<Returns>a block design</Returns>
<Description>
This method allows one to use the GAP package <Package>DESIGN</Package> 
to analyse a generalised polygon, so the user must first load this package.
The argument <A>gp</A> is a generalised polygon, and if it has a collineation group,
the block design is computed with this extra information and
thus the resulting design is easier to work with. Likewise, if <A>gp</A> is an elation
generalised quadrangle and it has an elation group, then we use the elation group's action
to efficiently compute the block design.

We should also point out that this method returns a <E>mutable</E> attribute
of <A>gp</A>, so that accquired information about the block design can be added. For example,
the automorphism group of the block design may be computed after the design is stored
as an attribute of <A>gp</A>. Normally, attributes of GAP objects are immutable.
<Example>
<#Include SYSTEM "../examples/include/gpolygons_blockdesign.include">
</Example>
</Description>
</ManSection>

</Section>

<Section Label="gp:elements">
<Heading>Elements of generalised polygons</Heading>

<ManSection>
<Heading>Collections of elements of generalised polygons</Heading>
<Attr Name="ElementsOfIncidencStructure" Arg="gp, i"/>
<Attr Name="Points" Arg="gp"/>
<Attr Name="Lines" Arg="gp"/>
<Returns>a collection of elements of a generalised polygon</Returns>
<Description>
<A>gp</A> is any generalised polygon, <A>i</A> is a natural number, necessarily <M>1</M> or <M>2</M>.
<F>ElementsOfIncidencStructure</F> returns the elements of type <M>i</M> of <A>gp</A>, <F>Ponints</F>
and <F>Lines</F> are the usual shortcuts.
<Example>
</Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Size" Arg="els"/>
<Returns>a number</Returns>
<Description>
<A>els</A> is a collection of elements of a generalised polygon. This operation returns
the number of element in <A>els</A>.
</Description>
</ManSection>

<ManSection>
<Heading>Creating elements from objects and retrieving objects from elements</Heading>
<Oper Name="ObjectToElement" Arg="gp, obj"/>
<Oper Name="ObjectToElement" Arg="gp, type, obj"/>
<Oper Name="UnderlyingObject" Arg="el"/>
<Returns>a collection of elements of a generalised polygon</Returns>
<Description>
To create elements in <A>gp</A> (of type <A>type</A>), one of the versions of
<F>ObjectToElement</F> can be used. It is checked wheter <A>obj</A> represents an elements
(of type <A>type</A>). To retrieve an underlying object of an element <A>el</A>, <F>UnderlyingObject</F>
can be used.
<Example>
<#Include SYSTEM "../examples/include/gpolygons_objectselements.include">
</Example>
</Description>
</ManSection>

<ManSection>
<Heading>Incidence</Heading>
<Oper Name="IsIncident" Arg="v,w"/>
<Oper Name="\*" Arg="v,w"/>
<Returns>true or false</Returns>
<Description>
Let <A>v</A> and <A>w</A> be two elements of a generalised polygon. It is checked if
the ambient geometry of the two elements are identical, and true is returned if and only if
the two elements are incident in their ambient geometry.
</Description>
</ManSection>

<ManSection>
<Oper Name="Span" Arg="v,w"/>
<Returns>a line of a generalised polygon or fail</Returns>
<Description>
Let <A>v</A> and <A>w</A> be two elements of a generalised polygon. It is checked if
the ambient geometries of the two elements are identical, and if the two elements are points.
If <A>v</A> and <A>w</A> are incidence with a common line, this line is returned. Otherwise
<K>fail</K> is returned. For generalised polygons constructed with <C>GeneralisedPolygonByBlocks</C>,
<C>GeneralisedPolygonByElements</C> an <C>GeneralisedPolygonByInidenceMatrix</C>, the underlying graph
is used. Note that the behavior of <F>Span</F> is different for elements of
generalised polygongs that belong to <C>IsLieGeometry</C>, see <Ref Label="liespan"/>.
<Example>
<#Include SYSTEM "../examples/include/gpolygons_span.include">
</Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="Meet" Arg="v,w"/>
<Returns>a point of a generalised polygon or fail</Returns>
<Description>
Let <A>v</A> and <A>w</A> be two elements of a generalised polygon. It is checked if
the ambient geometries of the two elements are identical, and if the two elements are lines.
If <A>v</A> and <A>w</A> are incidence with a common point, this point is returned. Otherwise
<K>fail</K> is returned. For generalised polygons constructed with <C>GeneralisedPolygonByBlocks</C>,
<C>GeneralisedPolygonByElements</C> an <C>GeneralisedPolygonByInidenceMatrix</C>, the underlying graph
is used. Note that the behavior of <F>Meet</F> is different for elements of
generalised polygongs that belong to <C>IsLieGeometry</C>, see <Ref Label="liemeet"/>
<Example>
<#Include SYSTEM "../examples/include/gpolygons_meet.include">
</Example>
</Description>
</ManSection>

<ManSection>
<Heading>Shadow elements</Heading>
<Oper Name="ShadowOfElement" Arg="geo, v, j"/>
<Oper Name="Points" Arg="el"/>
<Oper Name="Lines" Arg="el"/>
<Oper Name="ElementsIncidentWithElementOfIncidenceStructure" Arg="el, i"/>
<Returns> A collection of elements</Returns>
<Description>
<A>geo</A> is a generalised olygon, <A>v</A> must be an element of <A>geo</A>,
<A>j</A> is an integer equal to 1 or 2, since <A>geo</A> is a rank two geometry.
The operation <F>ShadowOfElement</F> returns the collection of elements of <A>geo</A> of type
<A>j</A>, incident with the element <A>v</A>. The operations <F>Points</F> and <F>Lines</F> with argument
are the usual shortcuts to <F>ShadowOfElement</F> with <A>j</A> respectively equal to 1, 2. The operation
<F>ElementsIncidentWithElementOfIncidenceStructure</F> is the usual shortcut to <F>ShadowOfElement</F>.
<Example>
<#Include SYSTEM "../examples/include/gpolygons_shadow.include">
</Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="DistanceBetweenElements" Arg="v,w"/>
<Returns>a number</Returns>
<Description>
Let <A>v</A> and <A>w</A> be two elements of a generalised polygon. It is checked if
the ambient geometry of the two elements are identical, and the distance between the two
elements in the incidence graph of their ambient geometry is returned.
<Example>
<#Include SYSTEM "../examples/include/gpolygons_distance.include">
</Example>
</Description>
</ManSection>

</Section>

<Section Label="CGH">
<Heading>The classical generalised hexagons</Heading>

<Subsection>
<Heading>mathematical backgroup</Heading>

</Subsection>

<ManSection>
<Oper Name="SplitCayleyHexagon" Arg="q"/>
<Oper Name="SplitCayleyHexagon" Arg="f"/>
<Oper Name="SplitCayleyHexagon" Arg="ps"/>
<Returns>a generalised hexagon</Returns>
<Description>
<Example>
<#Include SYSTEM "../examples/include/gpolygons_SplitCayleyHexagon.include">
</Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="TwistedTrialityHexagon" Arg="q"/>
<Oper Name="TwistedTrialityHexagon" Arg="f"/>
<Oper Name="TwistedTrialityHexagon" Arg="ps"/>
<Returns>a generalised hexagon</Returns>
<Description>
<Example>
<#Include SYSTEM "../examples/include/gpolygons_TwistedTrialityHexagon.include">
</Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="VectorSpaceToElement" Arg="gh, vec"/>
<Returns>an element of a classical generlised hexagon</Returns>
<Description>
</Description>
</ManSection>

<ManSection>
<Oper Name="ObjectToElement" Arg="gh, obj"/>
<Returns>an element of a classical generlised hexagon</Returns>
<Description>
</Description>
</ManSection>

<ManSection>
<Oper Name="UnderlyingObject" Arg="gh, obj"/>
<Returns>an element of a classical generlised hexagon</Returns>
<Description>
</Description>
</ManSection>

<ManSection>
<Oper Name="\in" Arg="x, gh"/>
<Returns>true or false</Returns>
<Description>
</Description>
</ManSection>

<ManSection>
<Heading>Span and meet of elements</Heading>
<Oper Name="Span" Arg="x, y"/>
<Oper Name="Meet" Arg="x, y"/>
<Returns>a subspace of a projective space</Returns>
<Description>
<Example>
</Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="CollineationGroup" Arg="gh"/>
<Returns>a group of collineations</Returns>
<Description>
give some nice examples.
<Example>
</Example>
</Description>
</ManSection>

</Section>

<Section Label="EGQ">
<Heading>Elation generalised quadrangles</Heading>

<Subsection>
<Heading>Elation generalised quadrangles and Kantor families</Heading>

Suppose <M>S=(P,B,I)</M> is a generalised quadrangle of order <M>(s,t)</M> for which
there exists a point <M>p</M> and a group of collineations <M>G</M> fixing
<M>P</M> and each line through <M>P</M>, with the extra property that
<M>G</M> acts regularly on the points not collinear with <M>p</M>. Then
<M>S</M> is called an <E>elation generalised quadrangle</E> with base point <M>P</M>
and elation group <M>G</M>, and <M>G</M> has order <Alt Not="HTML"><M>s^2t</M></Alt><Alt Only="HTML">s&lt;sup>2&lt;/sup>t</Alt>.
Let <M>y</M> be a fixed point of <M>S</M>, not collinear with <M>p</M>. Denote the <M>t+1</M>
lines incident with <M>p</M> as <Alt Not="HTML"><M>L_i, i=0 \ldots t</M></Alt>
<Alt Only="HTML">L&lt;sub>i&lt;/sub>, i=0 ... t</Alt>. Define for each line
<Alt Not="HTML"><M>L_i</M></Alt><Alt Only="HTML">L&lt;sub>i&lt;/sub></Alt> the unique
point-line pair <Alt Not="HTML"><M>(z_i,M_i)</M></Alt><Alt Only="HTML">(z&lt;sub>i&lt;/sub>,M&lt;sub>i&lt;/sub>)</Alt>
such that <Alt Not="HTML"><M>L_i I z_i I M_i I y</M></Alt>
<Alt Only="HTML">L&lt;sub>i&lt;/sub> I z&lt;sub>i&lt;/sub> I M&lt;sub>i&lt;/sub> I y</Alt>. Define the groups
<Alt Not="HTML"><M>S_i</M></Alt><Alt Only="HTML">S&lt;sub>i&lt;/sub></Alt> as the subgroups of <M>G</M> fixing the lines
<Alt Not="HTML"><M>M_i</M></Alt><Alt Only="HTML">M&lt;sub>i&lt;/sub></Alt>, and define the groups
<Alt Not="HTML"><M>S_i^*</M></Alt><Alt Only="HTML">S&lt;sub>i&lt;/sub>&lt;sup>*&lt;/sup></Alt> as the subgroups of
<M>G</M> fixing the point <Alt Not="HTML"><M>z_i</M></Alt><Alt Only="HTML">z&lt;sub>i&lt;/sub></Alt>.
Define the set <Alt Not="HTML"><M>J = \{S_i: i=0 \ldots t\}</M></Alt><Alt Only="HTML">J = {S&lt;sub>i&lt;/sub>: i=0 ... t}</Alt>,
and the set <Alt Not="HTML"><M>J^* = \{S_i: i=0 \ldots t\}</M></Alt>
<Alt Only="HTML">J&lt;sup>*&lt;/sup> = {S&lt;sub>i&lt;/sub>&lt;sup>*&lt;/sup>: i=0 ... t}</Alt>. Since <M>S</M> is an elation generalised quadrangle,
<M>J</M> is a collection of <M>t+1</M> subgroups of <M>G</M> of order <M>s</M>, and each <Alt Not="HTML"><M>S_i^*</M></Alt>
<Alt Only="HTML">S&lt;sub>i&lt;/sub>&lt;sup>*&lt;/sup></Alt> contains has order <M>st</M> and contains <Alt Not="HTML"><M>S_i</M></Alt>
<Alt Only="HTML">S&lt;sub>i&lt;/sub></Alt> as a subgroup. Furthermore, the following two conditions are satisfied.<P/>
(K1) <Alt Not="HTML"><M>S_iS_j \cap S_k = \{1\}</M></Alt>
<Alt Only="HTML">S&lt;sub>i&lt;/sub> S&lt;sub>j&lt;/sub> <M>\cap</M>S&lt;sub>k&lt;/sub> = {1}</Alt>, for distinct <M>i,j,k</M>.<P/>
(K2) <Alt Not="HTML"><M>S_i \cap S_j^* = \{1\}</M></Alt>
<Alt Only="HTML">S&lt;sub>i&lt;/sub>&lt;sup>*&lt;/sup> <M>\cap</M>S&lt;sub>j&lt;/sub> = {1}</Alt>, for distinct <M>i,j</M>.<P/>
The pair <Alt Not="HTML"><M>(J,J^*)</M></Alt><Alt Only="HTML">(J,J&lt;sup>*&lt;/sup>)</Alt> is called a <E>4-gonal family</E> or
<E>Kantor family</E> in <M>G</M>.<P/>
Noteworthy, each Kantor family in a group of order <Alt Not="HTML"><M>s^2t</M></Alt><Alt Only="HTML">s&lt;sup>2&lt;/sup>t</Alt>
gives rise to an elation generalised quadrangle. Kantor families and elation generalised quadrangles are equivalent objects,
and one of the motivations to study Kantor families in groups was to find examples of non-classical elation generalised quadrangles.<P/>
Given a group <M>G</M>, together with a Kantor family <Alt Not="HTML"><M>(J,J^*)</M></Alt><Alt Only="HTML">(J,J&lt;sup>*&lt;/sup>)</Alt>,
a generalised quadrangle is defined as follows.<P/>
The points are of three types:<P/>
(i) points of type 1 are the elements of <M>G</M>;<P/>
(ii) points of of type 2 are the right cosets <Alt Not="HTML"><M>S^*g, s^* \in J^*</M></Alt>
<Alt Only="HTML">S&lt;sup>*&lt;/sup>g, S&lt;sup>*&lt;/sup><M>\in</M> J&lt;sup>*&lt;/sup></Alt><P/>
(iii) the unique point of type (iii) is the symbol infinity.<P/>
The lines are of two types:<P/>
(a) lines of type (a) are the right cosets <M>Sg</M>, <M>S \in J</M>;<P/>
(b) Lines of type (b) are the symbols <M>[S], S \in J</M>.<P/>
Incidence is defined as follows. A point <M>g</M> of type (i) is incident with each
line <M>Sg, S \in J</M> of type (a). A point of type (ii) <Alt Not="HTML"><M>S^*g</M></Alt>
<Alt Only="HTML">S&lt;sup>*&lt;/sup>g</Alt> is incident the line <M>[S]</M> of type (b)
and the <M>t</M> lines of type (a) for which <Alt Not="HTML"><M>Sh \subset S^*g</M></Alt>
<Alt Only="HTML">Sh <M>\subset</M> S&lt;sup>*&lt;/sup>g</Alt>. Finally, the unique point of type (iii)
is incident with the lines of type (b), and there are no further incidences.<P/>
It is shown, see e.g. the standard work in this field of Payne and Thas <Cite Key="FGQ"/>, that this
point-line geoemtry is a generalised quadrangle of order <M>(s,t)</M>.<P/>
<Package>FinInG</Package> provides functions to construct elation generalised quadrangles
directly from a Kantor family. The constructed generalised quadrangles are generalised polygons in the
sense of <Package>FinInG</Package>, i.e. all generic operations described in Sections <Ref Sect="gp:operations"/> and
<Ref Sect="gp:elements"/>.

</Subsection>

<ManSection>
<Heading>Categories</Heading>
<Filt Name="IsEGQByKantorFamily" Type="Category"/>
<Filt Name="IsElementOfKantorFamily" Type="Category"/>
<Description>
<C>IsEGQByKantorFamily</C> is a subcategory of <C>IsElationGQ</C>. It contains all elations generalised quadrangles
that are constructed from a Kantor family. <C>IsElementOfKantorFamily</C> is a subcategory of <C>IsElementOfGeneralisedPolygon</C>.
It contains the elements from generalised quadrangles in the category <C>IsEGQByKantorFamily</C>.
</Description>
</ManSection>

<ManSection>
<Heading>Kantor families</Heading>
<Oper Name="IsKantorFamily" Arg="g,f,fstar"/>
<Returns>true or false</Returns>
<Description>
There is no specific way to construct a Kantor family in <Package>FinInG</Package>. However, given a group <M>G</M> and
two collections of subgroups, <F>IsKantorFamily</F> will check whether the input satisfies the conditions of a Kantor family.
If so, the input can be used directly for the operation <F>EGQByKantorFamily</F>.
</Description>
</ManSection>

<ManSection>
<Oper Name="EGQByKantorFamily" Arg="g,f,fstar"/>
<Returns>a generalised quadrangle</Returns>
<Description>
Let <A>g</A> be a group and <A>f</A> and <A>fstar</A> two collections of subgroups, satisfying the conditions of a Kantor
family. This operation returs the corresponding elation generalised quadrangle. Note that this operation <E>does not</E> check
if the input satisfies the conditions to be a Kantor family, it only checks wheter the group <A>f[i]</A> is a subgroup of the group
<A>fstar[i]</A>. In the example below, the use of <F>IsKantorFamily</F> is also
demonstrated, and some categories are displayed.
<Example>
<#Include SYSTEM "../examples/include/gpolygons_EGQByKantorFamily.include">
</Example>
</Description>
</ManSection>

<ManSection>
<Heading>Representation of elements and underlying objects</Heading>
<Oper Name="ObjectToElement" Arg="egq, t, obj"/>
<Oper Name="ObjectToElement" Arg="egq, obj"/>
<Oper Name="BasePointOfEGQ" Arg="egq"/>
<Oper Name="UnderlyingObject" Arg="egq, obj"/>
<Description>
For technical reasons, the underlying objects of the elements of an elation generalised quadrangle constructed from a Kantor family,
are not exactly the mathematical objects from the defintion. However, these technicalities are almost completely hidden for the user, except
for the representation of lines of type (b), which are represented in <Package>FinInG</Package> by the elements of the collection
<Alt Not="HTML"><M>J^*</M></Alt><Alt Only="HTML">J&lt;sup>*&lt;/sup></Alt> (instead of the elements of the collection <M>J</M>). This change
from the original definition has not mathematical implications, since there is a bijective correspondence between the elements of
<Alt Not="HTML"><M>J^*</M></Alt><Alt Only="HTML">J&lt;sup>*&lt;/sup></Alt> and <M>J</M>. Notice also that it is only possible to obtain
the basepoint of an elation generalised quadrangle constructed from a Kantor family through calling the attribute <F>BasePointOfEGQ</F>.
<Example>
<#Include SYSTEM "../examples/include/gpolygons_objectselementsofegq.include">
</Example>
</Description>
</ManSection>

<ManSection>
<Heading>Elation group and natural action on elements</Heading>
<Attr Name="ElationGroup" Arg="egq"/>
<Func Name="OnKantorFamily" Arg="g,el"/>
<Attr Name="CollineationAction" Arg="g"/>
<Description>
The attribute <F>ElationGroup</F> is naturally set upon creation of an elation generalised quadrangle from a Kantor
family. This elements of the elation group acts "naturally" on the elements of the elation generalised quadrangle. This
natural action is implements in the action function <F>OnKantorFamily</F>. When <A>g</A> is the elation group of an elation
generalised quadrangle constructed from a Kantor family, the attribute <F>CollineationAction</F> will return the action function
<F>OnKantorFamily</F>. The action function makes a use of generic GAP operations possible, as is demonstrated in the example.
<Example>
<#Include SYSTEM "../examples/include/gpolygons_elationgroup.include">
</Example>
</Description>
</ManSection>

<Subsection>
<Heading>Kantor families, q-clans, and elation generalised quadrangles</Heading>

Here comes a short mathematical description of how to find Kantor families from q-clans.

</Subsection>

<ManSection>
<Oper Name="qClan" Arg="list, f"/>
<Returns>
a q-clan.
</Returns>
<Description>
<Example>
</Example>
</Description>
</ManSection>

<ManSection>
<Heading>Built in q-clas</Heading>
<Oper Name="LinearqClan" Arg="q"/>
<Oper Name="FisherThasWalkerKantorBettenqClan" Arg="q"/>
<Oper Name="KantorMonomialqClan" Arg="q"/>
<Oper Name="KantorKnuthqClan" Arg="q"/>
<Oper Name="FisherqClan" Arg="q"/>
<Returns>
a q-clan.
</Returns>
<Description>
<Example>
</Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="KantorFamilyByqClan" Arg="clan"/>
<Returns>
A Kantor family.
</Returns>
<Description>
<Example>
</Example>
</Description>
</ManSection>

<ManSection>
<Oper Name="EGQByqClan" Arg="clan"/>
<Returns>
An elation generalised quadrangle constructed from a q-clan.
</Returns>
<Description>
<Example>
</Example>
</Description>
</ManSection>

<Subsection>
<Heading>BLT-sets, q-clans, and elation generalised quadrangles</Heading>

Here comes a short mathematical description of how to find a blt set from a q-clan, and how to define a GQ (which is a EGQ) from a blt set.
Noteworthy are the completely different representation of these GPs.

</Subsection>

<ManSection>
<Oper Name="BLTSetByqClan" Arg="clan"/>
<Returns>
A BLT-set.
</Returns>
<Description>
<Example>
</Example>
</Description>
</ManSection>


<ManSection>
<Oper Name="EGQByBLTSet" Arg="clan"/>
<Returns>
An elation generalised quadrangle.
</Returns>
<Description>
<Example>
</Example>
</Description>
</ManSection>


<Subsection>
<Heading>Flocks, BLT-sets and elation generalised quadrangles.</Heading>

The final subsection. The necesary mathematics.
</Subsection>

<ManSection>
<Oper Name="FlockGQByqClan" Arg="clan"/>
<Returns>
An elation generalised quadrangle.
</Returns>
<Description>
<Example>
</Example>
</Description>
</ManSection>



</Section>




</Chapter>



